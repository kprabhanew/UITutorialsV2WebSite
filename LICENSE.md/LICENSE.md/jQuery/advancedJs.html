<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>jQuery Intro</title>
<link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" type="text/css" href="../css/bootstrap.css">
<link rel="stylesheet" type="text/css" href="../style.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.3.15/angular.min.js"></script>
<!--<script src="scripts/jquery-1.10.2.js"></script>
<script src="scripts/bootstrap.js"></script>
<script src="scripts/angular.js"></script>-->
<script src="../app.js"></script>
</head>

<body data-spy="scroll" data-target="#myScrollspy">
<nav class="navbar navbar-inverse my-nav navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button>
      <a class="navbar-brand" href="#">uitutorials.in</a> </div>
    <div class="collapse navbar-collapse" id="myNavbar">
      <ul class="nav navbar-nav category-link">
        <li ><a href="../Bootstrap/htmlPages/grid.html">Bootstrap</a></li>                
        <li class="dropdown">
        <a class="active dropdown-toggle" data-toggle="dropdown" href="../angularjs.html">AngularJS
        <span class="caret"></span></a>
        <ul class="dropdown-menu">
          <li><a href="../angularjs_definitions.html">Definition</a></li>
          <li><a href="../angularjs_programs.html">Programs</a></li>
          <li><a href="../angularjs_examples.html">Examples</a></li>
          <li><a href="../angularjs_Questions.html">Quetions</a></li>
        </ul>
      </li>
        <li class="dropdown">
        <a class="active dropdown-toggle" data-toggle="dropdown" href="../jQuery.html">jQuery
        <span class="caret"></span></a>
        <ul class="dropdown-menu">          
          <li><a href="advancedJs.html">Advanced JS</a></li>
          <li><a href="ajax.html">Ajax</a></li>
          <li><a href="jQuery_examples.html">Examples</a></li>
          <li><a href="jQuery_Questions.html">Quetions</a></li>
        </ul>
      </li>
        <li><a href="#">Nodejs</a></li>
        
      </ul>
    </div>
  </div>
</nav>
<!--navigation Bar End-->
<div class="container page-content">
<div class="row">


<!--Right Column Wrapper Strat-->
<div class="col-sm-12">
<h1>Advanced javascript</h1>

<h3>Creational Pattern</h3>
<ul>
<li>Deals with the creation of new objects</li>
<li> Basically three ways to create objects:
     <ul>
     <li>var newObject = {};</li>
     <li>var newObject = Object.create(null);</li>
     <li>var newObject = new Object();</li>
     </ul>
 </li>
 <li>And four ways to assign a value to an object
     <ol>
         <li>Dot Syntax
             <ul>
             <li>newObject.someKey = 'Hello World'; // Write properties</li>
             <li>var key = newObject.someKey; // Access properties</li>
             </ul>     
         </li>
         <li>Square Brackets Syntax
            <ol>
                <li>newObject['someKey'] = 'Hello World';// Write properties</li>
                <li>var key = newObject['someKey']; // Access properties</li>
            </ol>
         </li>
         <li>defineProperty
            <pre>Object.defineProperty(newObject, "someKey", {
            value: "for more control of the property's behavior",
            writable: true,
            enumerable: true,
            configurable: true
            });</pre>
         </li>
         <li>defineProperties
            <pre>Object.defineProperties(newObject, {
                "someKey": {
                value: "Hello World",
                writable: true
                },
                "anotherKey": {
                value: "Foo bar",
                writable: false
                }
            });</pre>
         </li>
         
     
     </ol>
 </li>
 </ul>
 
<h3>Constructor Pattern</h3>

<ol>
<li>Basic Constructors
<pre>
function Car(model, year, miles) {
this.model = model;
this.year = year;
this.miles = miles;
this.toString = function () {
    return this.model + " has done " +
    this.miles + " miles";
    };
}
var civic = new Car("Honda Civic", 2009, 20000);
var mondeo = new Car("Ford Mondeo", 2010, 5000);
console.log(civic.toString());
console.log(mondeo.toString());
</pre>
</li>
<li>

</li>
Constructors with Prototype
<pre>
function Car(model, year, miles) {
    this.model = model;
    this.year = year;
    this.miles = miles;
}
Car.prototype.toString = function () {
    return this.model + " has done " +
    this.miles + " miles";
};
var civic = new Car("Honda Civic", 2009, 20000);
var mondeo = new Car("Ford Mondeo", 2010, 5000);
console.log(civic.toString());
console.log(mondeo.toString());
</pre>
</ol>
<p>
Several different patterns exist for structuring javascript code to make it resuable, maintainable, and help it avoid naming confilicts. Prototyping is a feature in the javascript languaage, and this particularr pattern is going to leverage prototyping functionality.</p>

<p>With the prototype pattern, you're going to have two parts to it,  that is going to be the constructor--and this will be where you typically define your variables--and then you'll have a separate section, normally right below that, that's going to be your function prototypes. </p>

<p>One of the main benefits, though, of this pattern that I'll show is that the functions are actually loaded up into memory once, so if you define 50 functions using this pattern, those 50 functions will be loaded up in the memory one time. So if you create let's say a hundred objects, they'll all share those same 50 functions in memory. It won't create a duplicate copy of each function. Now, normally, you'd be up to a lot more than that in memory if you had a hundred times say 50 functions, you're up at 5,000 functions now across all the objects. That's not the case with the prototype pattern.</p>

<h3>What is a Closure ?</h3>
    <p>An inner function always has access to the vars and parameters of its outer function, even after the outer function has returned.</p>
    
    <p><strong>Example :</strong> You have a nested function in an outer function. If you reference a variable(var date) in the nested function that's defined outside here, it will create a closure around it.
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;script type="text/javascript"&gt;
        window.onload = function() {
                var output = document.getElementById("Output");
                var nonClouse = myNonClouser();
                var Clouse = new myClosure2(); // Instantiate the function, then assign it to this variable
                output.innerHTML = Clouse.foo(); // function executed

                window.setTimeout(function() {
                    output.innerHTML += '&lt;br /&gt;' + Clouse.foo();
                }, 500);

            }
            //Non-Clouser Function
        function myNonClouser() {
            var date = new Date();
            return date.getMilliseconds();
        }

        //Clouser Function
        function myClouse() {
            var date = new Date();

            return function() {
                return date.getMilliseconds();
            }
        }

        function myClosure2() {
            var date = new Date();
            var myNestedFunc = function() {
                return date.getMilliseconds();
            }

            return { // Object Literal
                foo: myNestedFunc
            };
        }
    &lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div id="Output"&gt;&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
</pre>
<h3>Module Pattern</h3>
<ol>
<li> Module
    <ul>
    <li> Interchangeable single-part of a larger system that can be easily reused</li>
    </ul>
</li>
<li> Using the notion of IIFE: Immediately Invoked Function Expressions

<pre>
(function() {
// code to be immediately invoked
}());
</pre>
</li>
<li> Problem: there is no real privacy in JavaScript</li>
<li> The typical module pattern is where immediately invoked function expressions
(IIFEs) use execution context to create ‘privacy’
<ul><li>Here, objects are returned instead of functions.</li></ul>
</li>

<li>In the pattern
<ul>
<li> Variables declared are only available inside the module.</li>
<li> Variables defined within the returning object are available to everyone</li>
</ul>
</li>
</ol>
<pre>
var basketModule = (function() {
        var basket = []; //private
        return { //exposed to public
            addItem: function(values) {
                basket.push(values);
            },
            getItemCount: function() {
                return basket.length;
            },
            getTotal: function() {
                var q = this.getItemCount(),
                    p = 0;
                while (q--) {
                    p += basket[q].price;
                }
                return p;
            }
        }
    }());

    //basketModule is an object with properties which can  also be methods

    basketModule.addItem({ item: 'bread', price: 0.5 });
    basketModule.addItem({ item: 'butter', price: 0.3 });
    console.log(basketModule.getItemCount());
    console.log(basketModule.getTotal());

    //however, the following will not work:
    // (undefined as not inside the returned object)

    console.log(basketModule.basket); //error!

    //(only possible within the module scope)

    console.log(basket); //error
</pre>

<h3>Facade Pattern</h3>
<ul>
<li>Structural Pattern</li>
<li>Convenient, high-level interfaces to larger bodies of code that hide underlying complexity
	<ul>
    	<li> Aims to simplify the presented API to other developers</li>
    </ul>
<li>
<li>The facade pattern :
    <ul>
        <li>Simplifies the interface of a class</li>
        <li>Decouples the class from the code that uses it</li>
    </ul>
</li>
<li>
Facades can be used with the Module pattern in order to hide its
methods
    <ul>
        <li>It differs from the Module pattern as the limited public API differs greatly from
        the reality of the implementation.</li>
    </ul>
</li>
</ul>

<pre>
var module = (function() {
        var _private = {
            i: 5,
            get: function() {
                console.log('current value:' + this.i);
            },
            set: function(val) {
                this.i = val;
            },
            run: function() {
                console.log('running');
            },
            jump: function() {
                console.log('jumping');
            }
        };
        return {
            facade: function(args) {
                _private.set(args.val);
                _private.get();
                if (args.run) {
                    _private.run();
                }
            }
        }
    }());
    module.facade({ run: true, val: 10 });
    //outputs current value: 10, running
</pre>

<h3>Mediator Pattern</h3>
<ul>
<li>A mediator:
	<ul>
    	<li>A neutral party who assists in negotiations and conflict resolution.</li>
    </ul>
</li>
<li>Behavioural design pattern</li>

<li>Encapsulates how disparate modules interact with each other by acting as an intermediary
	<ul>
    	<li>If a system seems to have too many direct relationships between its modules
(colleagues), it may be time to have a central point of control that modules
communicate through instead.
		</li>
     </ul>
</li>
<li>A mediator:
    <ul>
        <li>Promotes loose coupling</li>
        <li>Modules can broadcast or listen for notifications without worrying about the rest of the system</li>    
    </ul>
</li>
</ul>
<pre>
var Participant = function(name) {
        this.name = name;
        this.chatroom = null;
    };
    Participant.prototype = {
        send: function(message, to) {
            this.chatroom.send(message, this, to);
        },
        receive: function(message, from) {
            log.add(from.name + " to " + this.name + ": " + message);
        }
    };
    var Chatroom = function() {
        var participants = {};
        return {
            register: function(participant) {
                participants[participant.name] = participant;
                participant.chatroom = this;
            },
            send: function(message, from, to) {
                if (to) { // single message
                    to.receive(message, from);
                } else { // broadcast message
                    for (key in participants) {
                        if (participants[key] !== from) {
                            participants[key].receive(message, from);
                        }
                    }
                }
            }
        };
    };
    
    // log helper
    var log = (function() {
        var log = "";
        return {
            add: function(msg) { log += msg + "\n"; },
            show: function() { alert(log);
                log = ""; }
        }
    })();

    function run() {
        var yoko = new Participant("Yoko");
        var john = new Participant("John");
        var paul = new Participant("Paul");
        var ringo = new Participant("Ringo");
        var chatroom = new Chatroom();
        chatroom.register(yoko);
        chatroom.register(john);
        chatroom.register(paul);
        chatroom.register(ringo);
        yoko.send("All you need is love.");
        yoko.send("I love you John.");
        john.send("Hey, no need to broadcast", yoko);
        paul.send("Ha, I heard that!");
        ringo.send("Paul, what do you think?", paul);
        log.show();
    }
</pre>
<hr>

<h2>Javascript Design Patterns
<!--<a href="../pdf/01Introduction.pdf" target="_blank">
<i class="fa fa-file-pdf-o" aria-hidden="true"></i></a>-->
</h2>
<div class="panel-group" id="intro"> <!-- Panel Group Start -->


<div class="panel panel-default"> <!-- Panel Start -->
<div class="panel-heading">
<h4 class="panel-title">
<a data-toggle="collapse" data-parent="#intro" href="#collapse22">
        01 Basic Introduction</a>
</h4>
</div>

<div id="collapse22" class="panel-collapse collapse ">
      <div class="panel-body">
      <ul class="nav nav-tabs">
  <li class="active"><a data-toggle="tab" href="#html22">Html</a></li>
  <li><a data-toggle="tab" href="#script22">Script</a></li>
<li><a data-toggle="tab" href="#description22">Description</a></li>  
</ul>

<div class="tab-content"> <!-- Tab Content Start  -->
  <div id="html22" class="tab-pane fade in active">
    <pre>
     &lt;body ng-app="sample"&gt; 
    Sum of 1 + 2 is {{ 1 + 2}}
  &lt;/body&gt;
	</pre>
  </div>
  <div id="script22" class="tab-pane fade">
    <pre>
    //--> 	"ng-app" stands for angular application.  
		//		-It is the root of angular application (starting at the element associated, "body" in this case).  
		//		-Usually one per web page / app (other workarounds available for multiple "ng-app")
		//		-Cannot be nested
		//		-Can be attached to any element, but usually to HTML or BODY
		//		-Usually attached to an angular module (called "root module")

		//-->	angular.module = all application logic under one umbrella. 
		//		-passing second parameter means, you are creating new module
		//		-empty square brackets means, the module has no dependencies (to load)
		//		-currently, the "sample" module is attached as "root module" (using ng-app)
        angular.module("sample", []); 		
		//-->	not passing second parameter means, 
		//		-search for and use existing module, which was already created earlier or in another file
		//angular.module("sample"); 

		//-->	{{ }} = angular expression
		//		javascript-like code snippets, evaulated by angular
		//		control flow statements, functions etc. NOT allowed
	</pre>
  </div>
  <div id="description22" class="tab-pane fade">
    <pre>
    //--> 	"ng-app" stands for angular application.  
		//		-It is the root of angular application (starting at the element associated, "body" in this case).  
		//		-Usually one per web page / app (other workarounds available for multiple "ng-app")
		//		-Cannot be nested
		//		-Can be attached to any element, but usually to HTML or BODY
		//		-Usually attached to an angular module (called "root module")

		//-->	angular.module = all application logic under one umbrella. 
		//		-passing second parameter means, you are creating new module
		//		-empty square brackets means, the module has no dependencies (to load)
		//		-currently, the "sample" module is attached as "root module" (using ng-app)
        angular.module("sample", []); 		
		//-->	not passing second parameter means, 
		//		-search for and use existing module, which was already created earlier or in another file
		//angular.module("sample"); 

		//-->	{{ }} = angular expression
		//		javascript-like code snippets, evaulated by angular
		//		control flow statements, functions etc. NOT allowed
	</pre>
  </div>  
</div> <!-- Tab content End -->
	  </div>
    </div>
</div> <!-- Panel ENd -->


</div> <!-- Panel Group End -->





</div> <!--Right Column Wrapper End col-sm-9-->
</div> <!--Container Row End-->
</div> <!--Container End-->

</body>
</html>